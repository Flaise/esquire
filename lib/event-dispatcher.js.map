{"version":3,"sources":["../src/event-dispatcher.js"],"names":[],"mappings":";;;;;;;;;;;;0BAAuB,eAAe;;;;IAEjB,eAAe;AACrB,aADM,eAAe,GAClB;8BADG,eAAe;;AAE5B,YAAI,CAAC,SAAS,GAAG,6BAAgB,CAAA;KACpC;;iBAHgB,eAAe;;eAI1B,gBAAC,QAAQ,EAAE;AACb,gBAAG,CAAC,QAAQ,CAAC,KAAK,EACd,MAAM,IAAI,KAAK,EAAE,CAAA;;;;AAIrB,gBAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAA;;AAE9C,mBAAO;uBAAM,IAAI,CAAC,MAAM,EAAE;aAAA,CAAA;SAC7B;;;eACQ,mBAAC,QAAQ,EAAE;AAChB,oBAAQ,EAAE,CAAA;AACV,mBAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;SAC/B;;;eACS,oBAAC,QAAQ,EAAE;;;AACjB,gBAAG,CAAC,QAAQ,CAAC,KAAK,EACd,MAAM,IAAI,KAAK,EAAE,CAAA;;AAErB,gBAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,UAAA,WAAW,EAAI;;;AAGpC,sBAAM,EAAE,CAAA;AACR,wBAAQ,CAAC,KAAK,CAAC,IAAI,aAAY,CAAA;aAClC,CAAC,CAAA;AACF,mBAAO,MAAM,CAAA;SAChB;;;eACG,cAAC,WAAY,EAAE;AACf,gBAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAA;SACxC;;;eACQ,qBAAU;8CAAN,IAAI;AAAJ,oBAAI;;;AACb,gBAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAA,QAAQ;uBAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;aAAA,CAAC,CAAA;SACjE;;;eACK,gBAAC,QAAQ,EAAE;;;AACb,gBAAM,MAAM,GAAG,IAAI,eAAe,EAAE,CAAA;;;AAGpC,gBAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,UAAA,WAAW,EAAI;AACtC,oBAAG,QAAQ,CAAC,KAAK,EACb,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,cAAY,CAAA;aAC3C,CAAC,CAAA;;AAEF,mBAAO,MAAM,CAAA;SAChB;;;eACQ,mBAAC,KAAK,EAAE;AACb,gBAAM,MAAM,GAAG,IAAI,eAAe,EAAE,CAAA;;;;AAIpC,gBAAM,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAA;AACrD,gBAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAA;;AAEtD,mBAAO,MAAM,CAAA;SAChB;;;eAES,eAAiB;+CAAb,WAAW;AAAX,2BAAW;;;AACrB,gBAAG,CAAC,WAAW,CAAC,MAAM,EAClB,OAAO,SAAS,CAAA;AACpB,gBAAI,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC,CAAA;AAC3B,iBAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC;AACzC,sBAAM,GAAG,MAAM,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAA;aAAA,AAC7C,OAAO,MAAM,CAAA;SAChB;;;WAjEgB,eAAe;;;qBAAf,eAAe","file":"src/event-dispatcher.js","sourcesContent":["import LinkedList from './linked-list'\n\nexport default class EventDispatcher {\n    constructor() {\n        this.callbacks = new LinkedList()\n    }\n    listen(callback) {\n        if(!callback.apply)\n            throw new Error()\n        \n        // it might break some behaviors to call listeners in reverse order but it allows insertion\n        // during iteration\n        const node = this.callbacks.addFirst(callback)\n        \n        return () => node.remove()\n    }\n    listen_pc(callback) {\n        callback()\n        return this.listen(callback)\n    }\n    listenOnce(callback) {\n        if(!callback.apply)\n            throw new Error()\n            \n        var remove = this.listen(__varargs__ => {\n            // remove will be initialized by the time this closure is called because there is no\n            // event for 'listener-added'\n            remove()\n            callback.apply(null, arguments)\n        })\n        return remove\n    }\n    proc(__varargs__?) {\n        this.base_proc.apply(this, arguments)\n    }\n    base_proc(...args) {\n        this.callbacks.forEach(callback => callback.apply(null, args))\n    }\n    filter(reactant) {\n        const result = new EventDispatcher()\n\n        ////////////////////////////////////////////////////// TODO: This listener needs to be removed when result has none of its own listeners, and re-added when it does\n        const remove = this.listen(__varargs__ => {\n            if(reactant.value)\n                result.proc.apply(result, arguments)\n        })\n\n        return result\n    }\n    aggregate(other) {\n        const result = new EventDispatcher()\n\n        ////////////////////////////////////////////////////// TODO: These listeners need to be removed when result has none of its own listeners, and re-added when it does\n        // using bind() to retain argument list\n        const removeA = this.listen(result.proc.bind(result))\n        const removeB = other.listen(result.proc.bind(result))\n\n        return result\n    }\n    \n    static any(...dispatchers) {\n        if(!dispatchers.length)\n            return undefined\n        let result = dispatchers[0]\n        for(let i = 1; i < dispatchers.length; i += 1)\n            result = result.aggregate(dispatchers[i])\n        return result\n    }\n}\n"]}