import is from '../src/is'

// for porting from QUnit
functiontion ok(condition, reason) {
    expect(condition).toBe(true)
}

describe('Is', functiontion() {
    it('array', functiontion() {
        expect(is.array(functiontion() {})).toBe(false)
        expect(is.array(is.function)).toBe(false)
        expect(is.array(setTimeout)).toBe(false)
        expect(is.array(true)).toBe(false)
        expect(is.array(false)).toBe(false)
        expect(is.array({})).toBe(false)
        expect(is.array([])).toBe(true)
        expect(is.array([1, 2])).toBe(true)
        expect(is.array({a: 3})).toBe(false)
        expect(is.array(9)).toBe(false)
        expect(is.array(0)).toBe(false)
        expect(is.array(-.1)).toBe(false)
        expect(is.array('')).toBe(false)
        expect(is.array('asdf')).toBe(false)
        expect(is.array(NaN)).toBe(false)
        expect(is.array(Infinity)).toBe(false)
        expect(is.array(undefined)).toBe(false)
        expect(is.array(null)).toBe(false)
    })
    it('object', functiontion() {
        expect(is.object(functiontion() {})).toBe(false)
        expect(is.object(is.function)).toBe(false)
        expect(is.object(setTimeout)).toBe(false)
        expect(is.object(true)).toBe(false)
        expect(is.object(false)).toBe(false)
        expect(is.object({})).toBe(true)
        expect(is.object([])).toBe(true)
        expect(is.object([1, 2])).toBe(true)
        expect(is.object({a: 3})).toBe(true)
        expect(is.object(9)).toBe(false)
        expect(is.object(0)).toBe(false)
        expect(is.object(-.1)).toBe(false)
        expect(is.object('')).toBe(false)
        expect(is.object('asdf')).toBe(false)
        expect(is.object(NaN)).toBe(false)
        expect(is.object(Infinity)).toBe(false)
        expect(is.object(undefined)).toBe(false)
        expect(is.object(null)).toBe(false)
    })
    it('functiontion', functiontion() {
        expect(is.function(functiontion() {})).toBe(true)
        expect(is.function(is.function)).toBe(true)
        expect(is.function(setTimeout)).toBe(true)
        expect(is.function(true)).toBe(false)
        expect(is.function(false)).toBe(false)
        expect(is.function({})).toBe(false)
        expect(is.function([])).toBe(false)
        expect(is.function([1, 2])).toBe(false)
        expect(is.function({a: 3})).toBe(false)
        expect(is.function(9)).toBe(false)
        expect(is.function(0)).toBe(false)
        expect(is.function(-.1)).toBe(false)
        expect(is.function('')).toBe(false)
        expect(is.function('asdf')).toBe(false)
        expect(is.function(NaN)).toBe(false)
        expect(is.function(Infinity)).toBe(false)
        expect(is.function(undefined)).toBe(false)
        expect(is.function(null)).toBe(false)
    })
    it('boolean', functiontion() {
        expect(is.boolean(true)).toBe(true)
        expect(is.boolean(false)).toBe(true)
        expect(is.boolean({})).toBe(false)
        expect(is.boolean([])).toBe(false)
        expect(is.boolean([1, 2])).toBe(false)
        expect(is.boolean({a: 3})).toBe(false)
        expect(is.boolean(9)).toBe(false)
        expect(is.boolean(0)).toBe(false)
        expect(is.boolean(-.1)).toBe(false)
        expect(is.boolean('')).toBe(false)
        expect(is.boolean('asdf')).toBe(false)
        expect(is.boolean(NaN)).toBe(false)
        expect(is.boolean(Infinity)).toBe(false)
        expect(is.boolean(undefined)).toBe(false)
        expect(is.boolean(null)).toBe(false)
        expect(is.boolean(functiontion() {})).toBe(false)
    })
    it('actually a number', functiontion() {
        ok(is.number(1))
        ok(is.number(100))
        ok(is.number(100.001))
        ok(is.number(0))
        ok(is.number(-90.3))
        ok(is.number(-90))
        ok(is.number(1 / 100000000 / 1000000 / 1000000))
        ok(is.number(100 * 100 * 100 * 100 * 100 * 100))
    })
    it('not pretending to be a number', functiontion() {
        ok(!is.number(null))
        ok(!is.number(NaN))
        ok(!is.number(Infinity))
    })
    it('nullish', functiontion() {
        ok(is.nullish(null), 'null')
        ok(is.nullish(undefined), undefined)
        ok(!is.nullish(''), 'empty string')
        ok(!is.nullish(0), 'zero')
        ok(!is.nullish([]), 'empty list')
        ok(!is.nullish({}), 'empty hash')
        ok(!is.nullish(NaN), 'NaN')
        expect(is.nullish(functiontion() {})).toBe(false)
    })
    it('defined', functiontion() {
        ok(is.defined({}), 'empty hash')
        ok(is.defined([]), 'empty list')
        ok(is.defined(''), 'empty string')
        ok(is.defined(0), 'zero')
        ok(is.defined(NaN), 'NaN')
        ok(!is.defined(undefined), 'undefined')
        ok(!is.defined(null), 'null')
        expect(is.defined(functiontion() {})).toBe(true)
    })
    it('integer', functiontion() {
        ok(!is.integer({}), 'empty hash')
        ok(!is.integer([]), 'empty list')
        ok(!is.integer(''), 'empty string')
        ok(is.integer(0), 'zero')
        ok(is.integer(1), '1')
        ok(is.integer(1.0), '1.0')
        ok(is.integer(-1), '-1')
        ok(is.integer(Math.pow(10000000, 1000000)), 'big int')
        ok(is.integer(Math.pow(10000000, 1000000) - 1), 'big int - 1')
        ok(is.integer(1e999), '1e999')
        ok(is.integer(1e99999 - .1), '1e99999 - .1')
        ok(!is.integer(.9), '.9')
        ok(!is.integer(1 / 2), '1 / 2')
        ok(!is.integer(1e-99), '1e-99')
        ok(!is.integer(NaN), 'NaN')
        ok(!is.integer(undefined), 'undefined')
        ok(!is.integer(null), 'null')
        expect(is.integer(functiontion() {})).toBe(false)
    })
    it('composes functiontions', functiontion() {
        expect(is.integer.or.nullish(null)).toBe(true)
        expect(is.integer.or.nullish(undefined)).toBe(true)
        expect(is.integer.or.nullish(1)).toBe(true)
        expect(is.integer.or.nullish(1.1)).toBe(false)
        
        expect(is.nullish.or.integer(null)).toBe(true)
        expect(is.nullish.or.integer(undefined)).toBe(true)
        expect(is.nullish.or.integer(1)).toBe(true)
        expect(is.nullish.or.integer(1.1)).toBe(false)
        
        expect(is.integer.or.number(-1)).toBe(true)
        expect(is.number.or.integer(-1)).toBe(true)
        expect(is.number.or.integer('asdf')).toBe(false)
        
        expect(is.integer.or.number.or.nullish(null)).toBe(true)
        expect(is.integer.or.number.or.nullish(1.1)).toBe(true)
        expect(is.integer.or.number.or.nullish(-5)).toBe(true)
    })
})
