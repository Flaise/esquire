'use strict'

var TileFieldAvatar = require('./tile-field-avatar')
var Smoothing = require('./smoothing')


// exporting this to silence warning generated by returning it from an exported function
export class SegmentedTileField {
    _rows = {}
    _fields = {}
    _tileSize
    _smoothingEnabled
    _layer = 0
    
    constructor(public avatars, tileSize, public divisionThreshold) {
        if(isNaN(divisionThreshold))
            throw new Error()
        this._tileSize = tileSize
    }
    
    _indexOf(x, y) {
        return Math.floor(x / this.divisionThreshold) + ',' + Math.floor(y)
    }
    _ensureRow(y) {
        var result = this._rows[y]
        if(!result) {
            result = new Smoothing(this.avatars)
            result.enabled = this.smoothingEnabled
            result.layer = y
            this._rows[y] = result
        }
        return result
    }
    _ensureField(x, y) {
        var fieldIndex = this._indexOf(x, y)
        var result = this._fields[fieldIndex]
        if(!result) {
            result = new TileFieldAvatar(this._ensureRow(y), this.tileSize)
            result.fieldGroup = this
            result.layer = x
            this._fields[fieldIndex] = result
        }
        return result
    }
    _modifyAt(x, y) {
        var field = this._fields[this._indexOf(x, y)]
        if(field)
            field._alter()
    }
    _modifyAround(x, y) {
        this._modifyAt(x - 1, y - 1)
        this._modifyAt(x + 1, y - 1)
        this._modifyAt(x - 1, y)
        this._modifyAt(x + 1, y)
        this._modifyAt(x - 1, y + 1)
        this._modifyAt(x + 1, y + 1)
    }
    
    hasTile(position, type) {
        var field = this._fields[this._indexOf(position.x, position.y)]
        if(!field)
            return false
        return field.hasTile(position, type)
    }
    drawSelectedTile(selector, type, x, y, layer, observedTypes) {
        var removal = this._ensureField(x, y).drawSelectedTile(selector, type, x, y, layer,
                                                               observedTypes)
        this._modifyAround(x, y)
        return () => {
            removal()
            this._modifyAround(x, y)
        }
    }
    drawTile(icon, x, y, layer, type) {
        var removal = this._ensureField(x, y).drawTile(icon, x, y, layer, type)
        this._modifyAround(x, y)
        return () => {
            removal()
            this._modifyAround(x, y)
        }
    }
    remove() {
        Object.keys(this._rows).forEach(key => this._rows[key].remove())
    }
    
    _forEach(callback) {
        Object.keys(this._fields).forEach(key => callback(this._fields[key]))
    }
    
    get tileSize() {
        return this._tileSize
    }
    set tileSize(value) {
        this._tileSize = value
        this._forEach(field => { field.tileSize = value })
    }
    
    get smoothingEnabled() {
        return this._smoothingEnabled
    }
    set smoothingEnabled(value) {
        this._smoothingEnabled = value
        Object.keys(this._rows).forEach(key => { this._rows[key].enabled = value })
    }
}

export function make(camera, tileSize, maxTileSize) {
    // limit pixel size to limit redraws - maximum is roughly 8000 on Firefox
    // subtract a few for objects that aren't contained by their tiles
    return new SegmentedTileField(camera.avatars, tileSize, Math.floor(5000 / maxTileSize) - 2)
}
